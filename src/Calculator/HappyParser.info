-----------------------------------------------------------------------------
Info file generated by Happy Version 1.19.5 from src/Calculator/HappyParser.y
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
Grammar
-----------------------------------------------------------------------------
	%start_parse -> All                                (0)
	All -> let var '=' Exprs                           (1)
	All -> fun fn vars ')' '=' Exprs                   (2)
	All -> fop op '(' num ',' num ')' '=' Exprs        (3)
	All -> Exprs                                       (4)
	Exprs -> Negate                                    (5)
	Exprs -> Negate op Exprs                           (6)
	Negate -> Expr                                     (7)
	Negate -> '-' Expr                                 (8)
	Expr -> '(' Exprs ')'                              (9)
	Expr -> fn exprs ')'                               (10)
	Expr -> num                                        (11)
	Expr -> var                                        (12)
	vars -> var                                        (13)
	vars -> vars ',' var                               (14)
	exprs -> Exprs                                     (15)
	exprs -> exprs ',' Exprs                           (16)

-----------------------------------------------------------------------------
Terminals
-----------------------------------------------------------------------------
	num            { TNumber $$ }
	var            { TIdent $$ }
	op             { TOp $$ }
	'('            { TLPar }
	')'            { TRPar }
	','            { TComma }
	'='            { TEqual }
	'-'            { TOp "-" }
	let            { TLet }
	fun            { TFun }
	fop            { TEnd }
	fn             { TFIdent $$ }

-----------------------------------------------------------------------------
Non-terminals
-----------------------------------------------------------------------------
	%start_parse    rule  0
	All             rules 1, 2, 3, 4
	Exprs           rules 5, 6
	Negate          rules 7, 8
	Expr            rules 9, 10, 11, 12
	vars            rules 13, 14
	exprs           rules 15, 16

-----------------------------------------------------------------------------
States
-----------------------------------------------------------------------------
State 0


	num            shift, and enter state 7
	var            shift, and enter state 8
	'('            shift, and enter state 9
	'-'            shift, and enter state 10
	let            shift, and enter state 2
	fun            shift, and enter state 11
	fop            shift, and enter state 12
	fn             shift, and enter state 13

	All            goto state 3
	Exprs          goto state 4
	Negate         goto state 5
	Expr           goto state 6

State 1


	let            shift, and enter state 2


State 2

	All -> let . var '=' Exprs                          (rule 1)

	var            shift, and enter state 21


State 3

	%start_parse -> All .                               (rule 0)

	%eof           accept


State 4

	All -> Exprs .                                      (rule 4)

	%eof           reduce using rule 4


State 5

	Exprs -> Negate .                                   (rule 5)
	Exprs -> Negate . op Exprs                          (rule 6)

	op             shift, and enter state 20
	')'            reduce using rule 5
	','            reduce using rule 5
	%eof           reduce using rule 5


State 6

	Negate -> Expr .                                    (rule 7)

	op             reduce using rule 7
	')'            reduce using rule 7
	','            reduce using rule 7
	%eof           reduce using rule 7


State 7

	Expr -> num .                                       (rule 11)

	op             reduce using rule 11
	')'            reduce using rule 11
	','            reduce using rule 11
	%eof           reduce using rule 11


State 8

	Expr -> var .                                       (rule 12)

	op             reduce using rule 12
	')'            reduce using rule 12
	','            reduce using rule 12
	%eof           reduce using rule 12


State 9

	Expr -> '(' . Exprs ')'                             (rule 9)

	num            shift, and enter state 7
	var            shift, and enter state 8
	'('            shift, and enter state 9
	'-'            shift, and enter state 10
	fn             shift, and enter state 13

	Exprs          goto state 19
	Negate         goto state 5
	Expr           goto state 6

State 10

	Negate -> '-' . Expr                                (rule 8)

	num            shift, and enter state 7
	var            shift, and enter state 8
	'('            shift, and enter state 9
	fn             shift, and enter state 13

	Expr           goto state 18

State 11

	All -> fun . fn vars ')' '=' Exprs                  (rule 2)

	fn             shift, and enter state 17


State 12

	All -> fop . op '(' num ',' num ')' '=' Exprs       (rule 3)

	op             shift, and enter state 16


State 13

	Expr -> fn . exprs ')'                              (rule 10)

	num            shift, and enter state 7
	var            shift, and enter state 8
	'('            shift, and enter state 9
	'-'            shift, and enter state 10
	fn             shift, and enter state 13

	Exprs          goto state 14
	Negate         goto state 5
	Expr           goto state 6
	exprs          goto state 15

State 14

	exprs -> Exprs .                                    (rule 15)

	')'            reduce using rule 15
	','            reduce using rule 15


State 15

	Expr -> fn exprs . ')'                              (rule 10)
	exprs -> exprs . ',' Exprs                          (rule 16)

	')'            shift, and enter state 28
	','            shift, and enter state 29


State 16

	All -> fop op . '(' num ',' num ')' '=' Exprs       (rule 3)

	'('            shift, and enter state 27


State 17

	All -> fun fn . vars ')' '=' Exprs                  (rule 2)

	var            shift, and enter state 26

	vars           goto state 25

State 18

	Negate -> '-' Expr .                                (rule 8)

	op             reduce using rule 8
	')'            reduce using rule 8
	','            reduce using rule 8
	%eof           reduce using rule 8


State 19

	Expr -> '(' Exprs . ')'                             (rule 9)

	')'            shift, and enter state 24


State 20

	Exprs -> Negate op . Exprs                          (rule 6)

	num            shift, and enter state 7
	var            shift, and enter state 8
	'('            shift, and enter state 9
	'-'            shift, and enter state 10
	fn             shift, and enter state 13

	Exprs          goto state 23
	Negate         goto state 5
	Expr           goto state 6

State 21

	All -> let var . '=' Exprs                          (rule 1)

	'='            shift, and enter state 22


State 22

	All -> let var '=' . Exprs                          (rule 1)

	num            shift, and enter state 7
	var            shift, and enter state 8
	'('            shift, and enter state 9
	'-'            shift, and enter state 10
	fn             shift, and enter state 13

	Exprs          goto state 34
	Negate         goto state 5
	Expr           goto state 6

State 23

	Exprs -> Negate op Exprs .                          (rule 6)

	')'            reduce using rule 6
	','            reduce using rule 6
	%eof           reduce using rule 6


State 24

	Expr -> '(' Exprs ')' .                             (rule 9)

	op             reduce using rule 9
	')'            reduce using rule 9
	','            reduce using rule 9
	%eof           reduce using rule 9


State 25

	All -> fun fn vars . ')' '=' Exprs                  (rule 2)
	vars -> vars . ',' var                              (rule 14)

	')'            shift, and enter state 32
	','            shift, and enter state 33


State 26

	vars -> var .                                       (rule 13)

	')'            reduce using rule 13
	','            reduce using rule 13


State 27

	All -> fop op '(' . num ',' num ')' '=' Exprs       (rule 3)

	num            shift, and enter state 31


State 28

	Expr -> fn exprs ')' .                              (rule 10)

	op             reduce using rule 10
	')'            reduce using rule 10
	','            reduce using rule 10
	%eof           reduce using rule 10


State 29

	exprs -> exprs ',' . Exprs                          (rule 16)

	num            shift, and enter state 7
	var            shift, and enter state 8
	'('            shift, and enter state 9
	'-'            shift, and enter state 10
	fn             shift, and enter state 13

	Exprs          goto state 30
	Negate         goto state 5
	Expr           goto state 6

State 30

	exprs -> exprs ',' Exprs .                          (rule 16)

	')'            reduce using rule 16
	','            reduce using rule 16


State 31

	All -> fop op '(' num . ',' num ')' '=' Exprs       (rule 3)

	','            shift, and enter state 37


State 32

	All -> fun fn vars ')' . '=' Exprs                  (rule 2)

	'='            shift, and enter state 36


State 33

	vars -> vars ',' . var                              (rule 14)

	var            shift, and enter state 35


State 34

	All -> let var '=' Exprs .                          (rule 1)

	%eof           reduce using rule 1


State 35

	vars -> vars ',' var .                              (rule 14)

	')'            reduce using rule 14
	','            reduce using rule 14


State 36

	All -> fun fn vars ')' '=' . Exprs                  (rule 2)

	num            shift, and enter state 7
	var            shift, and enter state 8
	'('            shift, and enter state 9
	'-'            shift, and enter state 10
	fn             shift, and enter state 13

	Exprs          goto state 39
	Negate         goto state 5
	Expr           goto state 6

State 37

	All -> fop op '(' num ',' . num ')' '=' Exprs       (rule 3)

	num            shift, and enter state 38


State 38

	All -> fop op '(' num ',' num . ')' '=' Exprs       (rule 3)

	')'            shift, and enter state 40


State 39

	All -> fun fn vars ')' '=' Exprs .                  (rule 2)

	%eof           reduce using rule 2


State 40

	All -> fop op '(' num ',' num ')' . '=' Exprs       (rule 3)

	'='            shift, and enter state 41


State 41

	All -> fop op '(' num ',' num ')' '=' . Exprs       (rule 3)

	num            shift, and enter state 7
	var            shift, and enter state 8
	'('            shift, and enter state 9
	'-'            shift, and enter state 10
	fn             shift, and enter state 13

	Exprs          goto state 42
	Negate         goto state 5
	Expr           goto state 6

State 42

	All -> fop op '(' num ',' num ')' '=' Exprs .       (rule 3)

	%eof           reduce using rule 3


-----------------------------------------------------------------------------
Grammar Totals
-----------------------------------------------------------------------------
Number of rules: 17
Number of terminals: 12
Number of non-terminals: 7
Number of states: 43
